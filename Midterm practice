1) Write a method AddF that adds a new element to the front of the list.

public void AddF(T data) {
    first = new Cell(data, first);
}

2) Write a method AddL that adds an element to the end of the list.

public void AddL(T data) {
    Cell newCell = new Cell(data, null);
    if (first == null) first = newCell;
    else {
        Cell current = first;
        while (current.Next != null)
            current = current.Next;
        current.Next = newCell;
    }
}

3) Write a method RemoveF() to remove the first node.

public void RemoveF() {
    if (first != null)
        first = first.Next;
}

4) Write a method Count() that returns the number of nodes.

public int Count() {
    int counter = 0;
    Cell current = first;
    while (current != null) {
        counter++;
        current = current.Next;
    }
    return counter;
}


5) Write an AddF and AddL for a doubly linked list.

public void AddF(T data) {
    Cell newCell = new Cell(data);
    newCell.Next = first;
    if (first != null) first.Prev = newCell;
    first = newCell;
    if (tail == null) tail = newCell;
}

public void AddL(T data) {
    Cell newCell = new Cell(data);
    newCell.Prev = tail;
    if (tail != null) tail.Next = newCell;
    tail = newCell;
    if (first == null) first = newCell;
}

6) Write a recursive inorder traversal

public void InOrder(Node node) {
    if (node != null) {
        InOrder(node.Left);
        Console.Write(node.Data + " ");
        InOrder(node.Right);
    }


7)   Write a method named Contains(T data) for a linked list class. The method should return true if the list contains the given data, and false otherwise. 

public bool Contains(T data)
{
    Cell current = first;
    while (current != null)
    {
        if (current.Data.Equals(data))
        {
            return true;
        }
        current = current.Next;
    }
    return false;
}

8) InsertNth to linked list

    public void InsertNth(int index, T data)
    {
        if (index < 0 || index > Count())
            throw new ArgumentOutOfRangeException(nameof(index));

        if (index == 0)
        {
            AddF(data);
            return;
        }
        
        Cell<T> current = first;
        for (int i = 0; i < index - 1; i++)
            current = current.Next;
        
        Cell<T> newCell = new Cell<T>(data, current.Next);
        current.Next = newCell;
    }

9) reverse linked list

    public void Reverse()
    {
        Cell<T> prev = null;
        Cell<T> current = first;
        Cell<T> next = null;

        while (current != null)
        {
            next = current.Next;
            current.Next = prev;
            prev = current;
            current = next;
        }

        first = prev;
    }

10) splitting and returning front and back halves of linked list

public (Cell<T> Front, Cell<T> Back) FrontBackSplit()
{

    if (first == null)
        return (null, null);
    if (first.Next == null)
        return (first, null);

    Cell<T> slow = first;
    Cell<T> fast = first.Next;

    While (fast != null)
    {
        fast = fast.Next;
        if (fast != null)
        {
            slow = slow.Next;
            fast = fast.Next;
        }
    }

    Cell<T> front = first;
    Cell<T> back = slow.Next;
    slow.Next = null; 

    return (front, back);
}


11) remove duplicates from linked list

public void RemoveDuplicates()
{
    if (first == null) return;

    var current = first;

    while (current.Next != null)
    {
        if (current.Data.Equals(current.Next.Data))
        {
            
            current.Next = current.Next.Next;
        }
        else
        {
            current = current.Next;
        }
    }
}

12) Move first node from one list and inserts it at the front of another list

public static void MoveNode(ref Cell<T> dest, ref Cell<T> source)
{
    if (source == null)
        throw new InvalidOperationException("Source list is empty.");


    Cell<T> node = source;
    source = source.Next;

    node.Next = dest;
    dest = node;
}


13) Splitting list into 2 by alternating nodes

public (Cell<T> A, Cell<T> B) AlternatingSplit()
{
    if (first == null)
        return (null, null);

    Cell<T> A = null;
    Cell<T> B = null;

    Cell<T> current = first;
    bool toA = true;

    while (current != null)
    {
        Cell<T> next = current.Next; 
        current.Next = null;        
        if (toA)
        {

            current.Next = A;
            A = current;
        }
        else
        {
            current.Next = B;
            B = current;
        }

        toA = !toA; 
        current = next;
    }


    A = ReverseList(A);
    B = ReverseList(B);

    return (A, B);
}
